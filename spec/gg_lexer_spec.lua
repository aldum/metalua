local describe = require("busted").describe
local assert = require("busted").assert
local it = require("busted").it
local pp = require("metalua.pprint").print
local M = require("mlua.grammar.lexer")

describe("lexer", function()
   local lexer = M.lexer
   describe("newstream", function()
      it("should return a new lexer stream", function()
         assert(lexer:newstream("a"))
      end)
      it("should initialize with sym and alpha fields", function()
         assert.are.same({}, lexer:newstream("a").sym)
         assert.are.same({}, lexer:newstream("a").alpha)
      end)
   end)
end)

describe("position", function()
   it("should return a new position", function()
      assert(M.new_position(1, 1, 1, "hello"))
      local pos = M.new_position(1, 1, 1, "hello")
      assert.are.same({ line = 1, column = 1, offset = 1, source = "hello", id = 5 }, pos)
   end)
   it("should print the string representation of position", function()
      local pos = M.new_position(1, 1, 1, "hello")
      assert.are.same("<hello|L1|C1|K1>", tostring(pos))
   end)
end)

describe("position_factory", function()
   local posfact = M.new_position_factory("hello world\n metalua is coollll", "hello.lua")
   it("should return a new position_factory", function()
      assert.are.same("hello.lua", posfact.src_name)
      assert.are.same({ 1, 13, 33 }, posfact.line2offset)
      assert.are.same(32, posfact.max)
   end)
   it("get the position of a given offset", function()
      local pos1 = posfact:get_position(14)
      assert.are.same("<hello.lua|L2|C2|K14>", tostring(pos1))
      local pos2 = posfact:get_position(2)
      assert.are.same("<hello.lua|L1|C2|K2>", tostring(pos2))
   end)
end)

describe("lineinfo", function()
   local posfact = M.new_position_factory("--preffix \nhello world\n metalua is coollll--suffix comments", "hello.lua")
   local pos1 = posfact:get_position(11)
   local pos2 = posfact:get_position(1)
   local lineinfo = M.new_lineinfo(pos1, pos2)
   it("represent a node's range in a source file", function()
      assert.are.same(pos1, lineinfo.first)
      assert.are.same(pos2, lineinfo.last)
   end)
   it("should print the string representation of position", function()
      assert.are.same("<hello.lua|L1|C11-1|K11-1>", tostring(lineinfo))
   end)
   -- TODO:
   it("embed information about prefix and suffix comments", function() end)
end)

describe("token", function()
   local posfact = M.new_position_factory("--preffix \nhello world\n metalua is coollll--suffix comments", "hello.lua")
   local pos1 = posfact:get_position(11)
   local pos2 = posfact:get_position(1)
   local lineinfo = M.new_lineinfo(pos1, pos2)
   local token = M.new_token("Op", "add", lineinfo)
   it("should return a new token", function()
      assert.are.same("Op", token.tag)
      assert.are.same("add", token[1])
   end)
   it("should print the string representation of position", function()
      assert.are.same('`Op "add"', tostring(token))
   end)
end)
